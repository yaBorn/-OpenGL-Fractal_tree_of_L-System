# OpenGL-Fractal_tree_of_L-System
【C++/OpenGL】基于L系统随机文法元的分形树
===
转载与调用请保留与注释原作者yaBorn的原文地址：https://github.com/yaBorn/-OpenGL-Fractal_tree_of_L-System

TODO:  
  1.报告编写ing   
  2.加入图片  
  3.整理cpp
---
班级：数媒1803班  
姓名：杨博文  
学号：1191180331  

此处应有图片*1(可能未显示，图片在<im_rd>中)  
深层迭代情况下的树，可以看出由三个文法元，随机迭代，层数够深时和自然状态的树很接近了。(不过深层迭代的性能8太行)  
 ![](https://github.com/yaBorn/-OpenGL-Fractal_tree_of_L-System/blob/main/im_md/1.png "深层迭代")

目录
---
* 运行说明
* 编写环境
* 调试说明
* 运行操作
* 效果
* 代码说明
  * 思路
  * 代码结构
  * 文法生成代码说明
  * 着色器渲染代码说明
* 许可

运行说明
---
* 直接下载解压<可执行程序_L分形树.rar>，内有dll，bmp*2，exe，点击exe运行即可。  
* 下载右侧发布Releases<_L.rar>也可以。 

此处应有动图*2(可能未显示，图片在<im_rd>中)    
 ![](https://github.com/yaBorn/-OpenGL-Fractal_tree_of_L-System/blob/main/im_md/%E5%88%87%E6%8D%A2%E6%96%87%E6%B3%95.gif "切换迭代文法")
 ![](https://github.com/yaBorn/-OpenGL-Fractal_tree_of_L-System/blob/main/im_md/%E8%A7%86%E8%A7%92.gif "视角")

编写环境
---
* VStudio 2017 (安装NuGet包管理器)  
* nupengl.core / nupengl.core.redist [dll下载](https://www.opengl.org/resources/libraries/glut/glutdlls37beta.zip)  
* [GLUT](https://www.opengl.org/resources/libraries/glut/)  

调试说明
---
1. 下载<VStudio源工程>，解压。
2. VS代开根目录sln文件。
3. 确保freeglut.dll在Debug文件夹内。
4. 点击源.cpp即为主代码。

运行操作
---
1. 下载<标识-可执行程序> 或右侧Releases<_L.rar>。  
2. 解压后，dll、bmp*2、exe文件处于同一程序目录下。  
3. 点击exe运行。  
4. 将打开命令行窗口与绘制窗口，鼠标点击绘制窗口。
5. 命令行窗口有操作说明。  

操作说明
---
  1 - 重新生成5迭代树     2 - 打开网线    3 - 打开纹理         4 - 减少迭代次数     5 - 增加迭代次数
  q - 返回初始机位                   e - 切换投影方式
                     w - 前移
  a - 左移           s - 后移        d - 右移
  z - 空间顺时旋转                   c - 空间逆时旋转
                     x - 关闭/打开网线
  鼠标滚轮向上滚动 - 上移            鼠标滚轮向下滚动 - 下移


效果
---
1. 旋转视角，无透视模式下查看分形树的整体。  
2. 按下e，切换至透视模式，w/s可前进后退查看分形树的细节。  
3. 大键盘3，打开/关闭纹理。  
4. 大键盘1，重新生成随机文法，对应分形树发送改变。  
5. 大键盘4/5，文法迭代深度，迭代深度越高，通常其分形树越复杂。  
   (因为文法元复杂度不同，连续使用复杂文法元导致浅层树可能较复杂)  
   **深度>8，可能导致性能下降**(因为迭代复杂规模n^2)  

代码说明
---
### TODO: CPP代码整理
核心代码在<code.cpp>
**一股脑**把文法生成代码+渲染器绘制代码+输入交互代码放一起了。比较冗杂。

### 思路
1. 使用了以前图形学的代码_读取bmp生成纹理。  
2. 利用分形的思想，并加入随机过程的影响，每次迭代分形时**随机选取预设分形策略**。  
3. 绘制前先根据分形思想，由初始字符串，根据文法生成元迭代字符串，然后根据字符串绘制分形树。
4. 文法生成规则如下:  
  (1). F绘制树干，X绘制叶子，AB更改树干参数，+-/*%&坐标变换，[]进出栈  
  (2). 如有文法**FA[+*&X][-/X][+%X]B**,则表示渲染器有如下操作  
       绘制树干->树干长度变化->坐标系入栈->坐标连续变换+*&->绘制叶子->坐标系出栈->坐标系入栈->...   
  (3). 文法终结于**叶子X**，按照**分形**与**数据结构_生成树**的思路，可以将**叶子X替换为另一段文法**，即将**叶子换为树干+叶子**，则这颗树"长大"了。太好了，好耶！  
  (4). 将叶子X替换为文法时，可以预设不同的文法生成元(类似(2)例子)，随机选择不同的生成元替换该文法。  
  (5). 由此，一段**简短**的初始文法将被**分形迭代**为复杂超超超超超级级级级级级级级长长长长长长长长长的文法。  
6. 遍历目标文法，switch判定此时渲染器操作。树生成完成，完美。  
7. 然后是一些简单的输入交互。

### 代码结构

### 文法生成代码

### 着色器渲染代码

许可
---
本项目使用 Apache 2.0 license.<br>
更多关于**许可**和**致谢**, 请参见 [LICENSE](LICENSE).
